<%_
function getUtilImportPath() {
  switch (clientFramework) {
    case 'react':
      return 'app/shared/util';
    case 'vue':
      return '@/core/util';
    default:
      return 'app/core/util';
  }
}
const utilImportPath = getUtilImportPath();
const onEvict = clientFramework === 'react'
        ? 'entity => toast.info(`Data for ${entity} has changed. Please Refresh to see the changes.`)'
        : 'entity => app.$root.$bvToast.toast(`Data for ${entity} has changed. Please Refresh to see the changes.`)';
%>
import { InMemoryCache, ApolloLink, HttpLink, split, ApolloClient, from } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
<%_ if (clientFramework === 'vue' || clientFramework === 'react') { _%>
import { BatchHttpLink } from '@apollo/client/link/batch-http';
<%_ } _%>
import { getMainDefinition } from '@apollo/client/utilities';
import { setContext } from '@apollo/client/link/context';
<%_ if (clientFramework === 'vue') { _%>
  import Vue from 'vue';
<%_ } _%>
import { PubSub } from '<%= utilImportPath %>/pub-sub';
import { GraphQLCacheWatcher } from '<%= utilImportPath %>/graphql-cache-watcher';
<%_ if (clientFramework === 'react') { _%>
import { toast } from 'react-toastify';
<%_ } _%>

export const httpUrl = '/graphql';
// TODO: build this dynamically (=> https://stackoverflow.com/a/44547904/2202290) problem: Proxy
export const wsUrl = 'ws://localhost:8081/graphql';
const AUTHENTICATION_TOKEN_KEY = 'jhi-authenticationToken';

function getToken(): string {
  return (localStorage.getItem(AUTHENTICATION_TOKEN_KEY) ?? sessionStorage.getItem(AUTHENTICATION_TOKEN_KEY) ?? '').replace(/"/g, '');
}

function getAuthorizationHeader(): string {
  const token = getToken();
  return token ? `Bearer ${token}` : "";
}

// remove accidentally passed __typename property from variables
export const omitTypenameLink = new ApolloLink((operation, forward) => {
  operation.variables = JSON.parse(JSON.stringify(operation.variables), (key: string, value: string) =>
    key === '__typename' ? undefined : value
  );
  // eslint-disable-next-line @typescript-eslint/no-unsafe-return
  return forward(operation);
});

// track all queries for caching
export function createRegisterQueryLink(pubsub: PubSub<string> = new PubSub<string>()): ApolloLink {
  return new ApolloLink((op, forward) => {
    const { operation, selectionSet } = getMainDefinition(op.query) as any;
    if (operation === 'query') {
      pubsub.publish(selectionSet.selections[0].name.value);
    }
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    return forward(op);
  });
}

// add authentication token
export const authLink = setContext((op, { headers }) => ({
  headers: {
    ...headers,
    authorization: getAuthorizationHeader(),
  }
}));

// split network layer: use webSocket for subscriptions and http for anything else
export function createNetworkLink(httpLink: ApolloLink): ApolloLink {
  return split(op => {
    const { kind, operation } = getMainDefinition(op.query) as any;
    return kind === 'OperationDefinition' && operation === 'subscription';
  },
    new WebSocketLink({
      uri: wsUrl,
      options: {
        reconnect: true,
        connectionParams: {
          headers: { authorization: getAuthorizationHeader() }
        }
      },
    }),
    httpLink
  );
}

export const cache = new InMemoryCache();

<% if ((clientFramework === 'react') || (clientFramework === 'vue')) { %>
const httpLink = new BatchHttpLink({ uri: httpUrl });
const networkLink = createNetworkLink(httpLink);
const pubSub = new PubSub<string>();
const registerQueryLink = createRegisterQueryLink(pubSub);

export const client = new ApolloClient({ cache, link: from([omitTypenameLink, registerQueryLink, authLink, networkLink]) });
<% } %>
<% if (clientFramework === 'react') { %>
const watcher = new GraphQLCacheWatcher(client, cache, pubSub, entity =>
  toast.info(`Data for ${entity} has changed. Please Refresh to see the changes.`));
watcher.connect();
<% } %>
<% if (clientFramework === 'vue') { %>
export function connectGraphQLCacheWatcher(app: Vue): void {
  const watcher = new GraphQLCacheWatcher(client, cache, pubSub, entity =>
    app.$root.$bvToast.toast(`Data for ${entity} has changed. Please Refresh to see the changes.`)
  );
  watcher.connect();
}
<% } %>

